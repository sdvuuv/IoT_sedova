
### Задача: 
Дан пример кода (см. blink.ipynb), в котором один светодиод мигает с использованием прерываний по переполнению таймера Timer1.
Необходимо расширить эту логику, чтобы управлять пятью светодиодами, каждый из которых мигает с разной частотой.
Период мигания каждого светодиода должен определяться как целое число временных интервалов, задаваемых таймером.
Частоту таймера или задержку напрямую указывать нельзя — нужно использовать периодические прерывания для отслеживания прошедших интервалов.




### Требования:
- нельзя использовать функции delay() или millis();
- настройка пинов должна выполняться через регистры DDRx, PINx, PORTx (без pinMode(), digitalRead(), digitalWrite() и т. п.);
- нельзя жёстко задавать периоды мигания — они должны выражаться как целое кратное минимальной единице времени;
- используется один таймер для всех пинов;
- необходимо применять побитовые операторы (|, &, >> и т. д.) для изменения состояния регистров;
- прерывания таймера должны происходить точно по времени, с разрешением 1/16000000 секунды, без приблизительных задержек.

### Рассмотрим код и логику его работы.

##### Глобальные константы и переменные
```c++

const int BASE_PERIOD_INTERVALS = 15;
const int NUM_LEDS = 5;
volatile unsigned int ledCounters[NUM_LEDS] = {0};

```
- BASE_PERIOD_INTERVALS: - константа, определяющая, сколько раз должно сработать прерывание таймера, чтобы самый быстрый светодиод изменил свое состояние
- NUM_LEDS: - количество управляемых светодиодов
- ledCounters: - массив счетчиков

##### setup()

```c++

void setup() {
  cli();
  DDRB |= 0b00011111;

  TCCR1A = 0;
  TCCR1B = 0;

  TCCR1B |= (1 << WGM12);
  TCCR1B |= (1 << CS12);
  OCR1A = 624;
  TIMSK1 |= (1 << OCIE1A);
  sei();
}

```
- cli() - глобально отключает все прерывания
- DDRB |= 0b00011111 - операция "ИЛИ" (|=), чтобы установить в 1 младшие 5 бит регистра DDRB, не затрагивая старшие 
- TCCR1A = 0; TCCR1B = 0 - полная очистка регистров управления Timer1 для начала конфигурации.
- TCCR1B |= (1 << WGM12) - устанавливаем бит WGM12
- TCCR1B |= (1 << CS12) - устанавливаем бит CS12
- OCR1A = 624 - настройка частоты
- TIMSK1 |= (1 << OCIE1A) - разрешаем прерывание TIMER1_COMPA_vect
- sei() - глобально разрешает прерывания.


###### обработчик прерывания

```c++

ISR(TIMER1_COMPA_vect) {
  for (int i = 0; i < NUM_LEDS; i++) {
    ledCounters[i]++;
    unsigned int targetPeriod = (i + 1) * BASE_PERIOD_INTERVALS;

    // проверяем достиг ли счетчик вычисленного периода
    if (ledCounters[i] >= targetPeriod) {
      // инвертируем 
      PORTB ^= (1 << i);

      ledCounters[i] = 0;
    }
  }
}

```

- Цикл for проходит по всем пяти светодиодам
- Счетчик для каждого светодиода увеличивается на 1 при каждом вызове ISR
- unsigned int targetPeriod = (i + 1) * BASE_PERIOD_INTERVALS - период для текущего светодиода.
- if (ledCounters[i] >= targetPeriod) - если достигает нужного значения, выполняется тело условия
- PORTB ^= (1 << i) - инвертирование состояния пина. (1 << i) создает битовую маску. xor инвертирует только тот бит в, который соответствует 1 в маске
- ledCounters[i] = 0 - cчетчик сбрасывается, и отсчет начинается заново




